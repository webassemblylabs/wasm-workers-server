---
sidebar_position: 6
---

# Zig

Zig workers are tested with Zig version `0.12.0`. Then, they are loaded by Wasm Workers Server and start processing requests.

## Your first Zig worker

The recommended way to implement workers is by using the `wws.zig` SDK.

In this example, the worker will get a request and print all the related information.

1. Create a new Zig project:

    ```shell-session
    zig init
    ```

2. Add Wasm Workers Server Zig dependency

    At this point in time, the Zig SDK is located at a subpath of the wasm-workers-server repo. Zig's package manager works with archives and does not support referencing a package as a subpath of an archive. We will therefore add wasm-workers-server as a submodule of our project.

    ```shell-session
    mkdir lib
    git submodule add https://github.com/vmware-labs/wasm-workers-server.git lib/wws
    ```

3. Add the wws dependency to `build.zig.zon`

    We can now modify the `build.zig.zon` file to include the Zig SDK as a dependency:

    ```zig title="build.zig.zon"
    .{
        // ...
        .dependencies = .{
            // Add this to dependencies
            .wws = .{
                .path = "lib/wws/kits/zig/wws",
            },
        },
        // ...
    }
    ```

4. Edit the `build.zig`

    The WWS Zig SDK exports a few build-time helpers to compile your executable to WASM and generate your worker config. Let's update the `build.zig` to include the `wws` dependency and build our worker and its associated config.

    ```zig title="build.zig"
    const std = @import("std");
    const wws = @import("wws");

    pub fn build(b: *std.Build) !void {
        // getTarget is a helper to get the proper wasm target
        const target = wws.getTarget(b);

        const optimize = b.standardOptimizeOption(.{});

        // This references the wws dependency we added to build.zig.zon
        const wws_dep = b.dependency("wws", .{});

        // addWorker lets us specify similar options to std.Build.addExecutable
        const worker = try wws.addWorker(b, .{
            .name = "example",
            // path lets us specify the file path for our worker and its config.
            // This will affect routing.
            .path = "hello/[name]",
            .root_source_file = .{ .path = "src/main.zig" },
            .target = target,
            .optimize = optimize,
            // We need to pass the wws dependency to addWorker so it can make sure
            // that the wws module is provided to your application.
            .wws = wws_dep,
            // features lets you specify which WWS features your worker will have
            // access to.
            .features = .{ .kv = .{ .namespace = "example" } },
        });

        // We use addWriteFiles to provide an output destination for our worker
        // and its config.
        const wf = b.addWriteFiles();

        // addToWriteFiles will add the compiled wasm and worker config to a subpath
        // determined by the path provided to addWorker above.
        try worker.addToWriteFiles(b, wf);

        {
            // Copy the wf directory contents into the zig-out directory.
            const install = b.addInstallDirectory(.{
                .source_dir = wf.getDirectory(),
                .install_dir = .prefix,
                // The contents of wf will be accessible in zig-out/root.
                .install_subdir = "root",
            });

            b.getInstallStep().dependOn(&install.step);
        }
    }
    ```

5. Edit `src/main.zig`  to match the following contents:

    ```zig title="src/main.zig"
    const std = @import("std");
    const wws = @import("wws");

    const tmpl =
        \\<!DOCTYPE html>
        \\<head>
        \\<title>Wasm Workers Server</title>
        \\<meta name="viewport" content="width=device-width,initial-scale=1">
        \\<meta charset="UTF-8">
        \\<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/water.css@2/out/water.css">
        \\<style>
        \\body {{ max-width: 1000px; }}
        \\main {{ margin: 5rem 0; }}
        \\h1, p {{ text-align: center; }}
        \\h1 {{ margin-bottom: 2rem; }}
        \\pre {{ font-size: .9rem; }}
        \\pre > code {{ padding: 2rem; }}
        \\p {{ margin-top: 2rem; }}
        \\</style>
        \\</head>
        \\<body>
        \\<main>
        \\<h1>Hello {[name]s} from Wasm Workers Server üëã</h1>
        \\<pre><code>Replying to {[url]s}
        \\Method: {[method]s}
        \\User Agent: {[user_agent]s}
        \\Payload: {[payload]s}</code></pre>
        \\<p>
        \\This page was generated by a Zig‚ö°Ô∏è file running in WebAssembly.
        \\</p>
        \\<form method="POST">
        \\<div><label>What is your name? <input type="text" name="name" value="WWS"/></label></div>
        \\<div><label>What is your favourite programming language? <input type="text" name="language" value="Zig"/></label></div>
        \\<input type="submit" value="Submit" />
        \\</form>
        \\</main>
        \\</body>
    ;

    fn handle(arena: std.mem.Allocator, request: wws.Request) !wws.Response {
        const payload = if (request.body.len == 0) "-" else request.body;
        const user_agent = request.headers.map.get("user-agent") orelse "-";
        const name = request.params.map.get("name") orelse "world";

        const body = try std.fmt.allocPrint(arena, tmpl, .{
            .url = request.url,
            .method = request.method,
            .user_agent = user_agent,
            .payload = payload,
            .name = name,
        });

        var response = wws.Response{
            .data = body,
        };

        try response.headers.map.put(arena, "x-generated-by", "wasm-workers-server");

        return response;
    }

    pub fn main() !void {
        var gpa = std.heap.GeneralPurposeAllocator(.{}){};
        defer _ = gpa.deinit();

        const parse_result = try wws.parseStream(gpa.allocator(), .{});
        defer parse_result.deinit();

        var arena = std.heap.ArenaAllocator.init(gpa.allocator());
        defer arena.deinit();

        const request = parse_result.value;
        const response = try handle(arena.allocator(), request);

        const stdout = std.io.getStdOut();
        try wws.writeResponse(response, stdout.writer());
    }
    ```

6. Compile the project

    ```shell-session
    $ zig build
    $ tree zig-out
    zig-out
    ‚îî‚îÄ‚îÄ root
        ‚îî‚îÄ‚îÄ hello
            ‚îú‚îÄ‚îÄ [name].toml
            ‚îî‚îÄ‚îÄ [name].wasm
    ```

7. Run your worker with `wws`. If you haven't downloaded the `wws` server yet, check our [Getting Started](../get-started/quickstart.md) guide.

    ```shell-session
    $ wws zig-out/root/
    ‚öôÔ∏è  Preparing the project from: zig-out/root/
    ‚öôÔ∏è  Loading routes from: zig-out/root/
    ‚è≥ Loading workers from 1 routes...
    ‚úÖ Workers loaded in 35.659083ms.
        - http://127.0.0.1:8080/hello/[name]
          => zig-out/root/hello/[name].wasm
    üöÄ Start serving requests at http://127.0.0.1:8080
    ```

8. Finally, open <http://127.0.0.1:8080/hello/world> in your browser.

## Add a Key / Value store

Wasm Workers allows you to add a Key / Value store to your workers. Read more information about this feature in the [Key / Value store](../features/key-value.md) section.

We can add a KV store to our Zig worker by specifying it inside `features` when we call `wws.addWorker`:

```zig title="build.zig"
pub fn build(b: *std.Build) !void {
    // ...

    const worker = try wws.addWorker(b, .{
        .name = "workerkv",
        .root_source_file = .{ .path = "src/main.zig" },
        .target = target,
        .optimize = optimize,
        .wws = wws_dep,
        .features = .{
            // Define your KV namespace here
            .kv = .{ .namespace = "workerkv" },
        },
    });

    // ...
}
```

We can see the resulting TOML configuration file when we call `build.zig`:

```shell-session
$ zig build
$ tree zig-out/root
zig-out/root/
‚îú‚îÄ‚îÄ workerkv.toml
‚îú‚îÄ‚îÄ workerkv.wasm
$ cat zig-out/root/workerkv.toml
name = "workerkv"
version = "1"
[data]
[data.kv]
namespace = "workerkv"
```

Then, we can read from/write to the KV store with the following example:

```zig title="src/main.zig"
const std = @import("std");
const wws = @import("wws");

const tmpl =
    \\<!DOCTYPE html>
    \\<head>
    \\<title>
    \\Wasm Workers Server - KV example</title>
    \\<meta name="viewport" content="width=device-width,initial-scale=1">
    \\<meta charset="UTF-8">
    \\</head>
    \\<body>
    \\<h1>Key / Value store in Zig</h1>
    \\<p>Counter: {d}</p>
    \\<p>This page was generated by a Zig‚ö°Ô∏è file running in WebAssembly.</p>
    \\</body>
;

fn handle(arena: std.mem.Allocator, request: wws.Request) !wws.Response {
    const value = request.kv.map.get("counter") orelse "0";
    var counter = std.fmt.parseInt(i32, value, 10) catch 0;

    counter += 1;

    const body = try std.fmt.allocPrint(arena, tmpl, .{counter});

    var response = wws.Response{
        .data = body,
    };

    const num_s = try std.fmt.allocPrint(arena, "{d}", .{counter});
    try response.kv.map.put(arena, "counter", num_s);

    try response.headers.map.put(arena, "x-generated-by", "wasm-workers-server");

    return response;
}

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();

    const parse_result = try wws.parseStream(gpa.allocator(), .{});
    defer parse_result.deinit();

    var arena = std.heap.ArenaAllocator.init(gpa.allocator());
    defer arena.deinit();

    const request = parse_result.value;
    const response = try handle(arena.allocator(), request);

    const stdout = std.io.getStdOut();
    try wws.writeResponse(response, stdout.writer());
}
```

## Dynamic routes

You can define [dynamic routes by adding route parameters to your worker files](../features/dynamic-routes.md) (like `[id].wasm`). Using the Zig SDK, you can configure this in your `build.zig` when you declare your worker:

```zig title="build.zig"
pub fn build(b: *std.Build) !void {
    // ...

    const worker = try wws.addWorker(b, .{
        .name = "params",
        // We specify the file path (and therefore the HTTP route) of our worker
        .path = "params/[id]",
        .root_source_file = .{ .path = "src/main.zig" },
        .target = target,
        .optimize = optimize,
        .wws = wws_dep,
    });

    // ...
}
```

If we run `zig build`, we can see the resulting file tree:

```shell-session
$ zig build
$ tree zig-out/root
zig-out/root/
‚îú‚îÄ‚îÄ params/[id].toml
‚îú‚îÄ‚îÄ params/[id].wasm
```

Then, you can read the params from the request with the following example:

```zig title="src/main.zig"
const std = @import("std");
const wws = @import("wws");

const tmpl =
    \\Hey! The parameter is: {s}
;

fn handle(arena: std.mem.Allocator, request: wws.Request) !wws.Response {
    const id = request.params.map.get("id") orelse "the value is not available";

    const body = try std.fmt.allocPrint(arena, tmpl, .{id});

    var response = wws.Response{
        .data = body,
    };

    try response.headers.map.put(arena, "x-generated-by", "wasm-workers-server");

    return response;
}

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    const parse_result = try wws.parseStream(allocator, .{});
    defer parse_result.deinit();
    const request = parse_result.value;

    var arena_impl = std.heap.ArenaAllocator.init(allocator);
    defer arena_impl.deinit();
    const arena = arena_impl.allocator();

    const response = try handle(arena, request);

    const stdout = std.io.getStdOut();
    try wws.writeResponse(response, stdout.writer());
}
```

## Read environment variables

Environment variables are configured [via the related TOML configuration file](../features/environment-variables.md). While using the Zig SDK, this configuration file is generated for us when we call `wws.addWorker` in our `build.zig`:

```zig title="build.zig"
pub fn build(b: *std.Build) !void {
    // ...

    const worker = try wws.addWorker(b, .{
        .name = "envs",
        .root_source_file = .{ .path = "src/main.zig" },
        .target = target,
        .optimize = optimize,
        .wws = wws_dep,
        .features = .{
            // Define your environment variables here
            .vars = &.{
                .{
                    .name = "MESSAGE",
                    .value = "Hello üëã! This message comes from an environment variable",
                },
            },
        },
    });

    // ...
}
```

```shell-session
$ zig build
$ tree zig-out/root
zig-out/root/
‚îú‚îÄ‚îÄ envs.toml
‚îú‚îÄ‚îÄ envs.wasm
$ cat zig-out/root/envs.toml
name = "envs"
version = "1"
[vars]
MESSAGE = "Hello üëã! This message comes from an environment variable"
```

These variables are accessible via `std.process.getEnvMap` or `std.process.getEnvVarOwned` in your worker. To read them, just use the same name you configured in `build.zig`:

```zig title="envs.zig"
const std = @import("std");
const wws = @import("wws");

const tmpl =
    \\The environment variable value is: {s}
;

fn handle(arena: std.mem.Allocator) !wws.Response {
    const envvar = std.process.getEnvVarOwned(arena, "MESSAGE") catch "";

    const body = try std.fmt.allocPrint(arena, tmpl, .{envvar});

    var response = wws.Response{
        .data = body,
    };

    try response.headers.map.put(arena, "x-generated-by", "wasm-workers-server");

    return response;
}

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();

    var arena = std.heap.ArenaAllocator.init(gpa.allocator());
    defer arena.deinit();

    const response = try handle(arena.allocator());

    const stdout = std.io.getStdOut();
    try wws.writeResponse(response, stdout.writer());
}
```

If you prefer, you can configure the environment variable value dynamically by following [these instructions](../features/environment-variables.md#inject-existing-environment-variables).

## Other examples

Find other examples in the [`/examples` directory](https://github.com/vmware-labs/wasm-workers-server/tree/main/examples/) of wasm-workers-server repository.

## Contributors

The Zig kit was originally authored for Zig 0.11 by Christoph Voigt ([@voigt](https://github.com/voigt)). It was then updated for Zig 0.12 by Christopher Grass([@sea-grass](https://github.com/sea-grass)).

## Feature compatibility

[Workers' features](../features/all.md) that are available in Zig:

| [K/V Store](../features/key-value.md) | [Environment Variables](../features/environment-variables.md) | [Dynamic Routes](../features/dynamic-routes.md) | [Folders](../features/mount-folders.md) | [HTTP Requests](../features/http-requests.md) |
| --- | --- | --- | --- | --- |
|  ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚ùå |
